An issue I ran into when using IntelliJ IDEA is not being able to view Java source code, declarations, and Javadocs. This can be resolved by going to your `src` folder (i.e., where your source code is located). Right click, navigate and toggle: __Mark Directory As > Sources Root__ ([link](https://stackoverflow.com/questions/37282285/intellij-cannot-find-any-declarations])).

__Meaning of `public` class?__

A public class has "public" visibility which means that it is accessible to any class in any package. If a class does not have the `public` access modifier, then it has "default" package visibility which means that it is accessible only to classes inside the same package.

__What is `transient` keyword?__

The `transient` keyword in Java is used to indicate that a field should not be part of the serialization. A `transient` variable is not part of the persistent state of an object. For example, if you have fields that are derived from other fields (programatically) then we can mark them as `transient` to prevent their state from being persisted during serialization. This helps save memory and increases speed of serialization / deserialization process. Say we have a `GalleryImage` class that `implements Serializable`. Among other instance variables / methods, assume this class contains two instance variables: `image` and `thumbnailImage`. The `thumbnailImage` is derived from the gallery `image`. Upon deserialization, the `readObject` method is called to perform any operations necessary to restore the state of the object. In this example, the `thumbnailImage` needs to be regenerated. Thus, we override the `readObject` method do that the thumbnail will be generated by calling a `generateThumbnail` method ([link](https://stackoverflow.com/questions/910374/why-does-java-have-transient-fields)).

# Software Design

## Change 

Change is distinguishing feature that makes software different from any other human produced artifact:
- Since the 1970's, change in software is constant, urgent, and unavoidable. Mastering change is inevitable.
- Software technology has made progress but change is treated as an afterthought.
- Change has to become a first class concept
  - development tools, runtime environment, and design process should naturally accomodate change

Two types of change:
1. Evolution, and
2. Adaptation

__Evolution:__ enhancing the software with new functions and features

__Adaptation:__ retrofitting or improving the relevance of a software system in a new environment (e.g., building mobile versions of desktop apps, porting Windows based app to MacOS).

__Change of Social Environment__
- change is necessary due to external influence
- factors beyond the control of software organizations, clients, and users
- changes are often hard to anticipate and difficult to implement
- often, programmers have to respond to these changes under severe time pressure

Examples of changes that require software change:
- new tax laws (for a tax software.. e.g., TurboTax)
- move of EU to common currency
- change in safety requirements (e.g., Boeing)

## Modules

__Properties of USES relationship__

__fan-in__: number of incoming edges indicates the number of modules that use (or "depend") on this module.

__fan-out__: number of outgoing edges indicates the number of modules this module depend on

Low fan-out / high fan-in is desirable because:
- this implies loose coupling (modules are not highly dependent on each other). Loose coupling increases maintainability, scalability, and reduces bugs
- implies that modules are a good abstraction

__Properties of modular design__

Principles:
- each module should address a specific subfunction of the requirements
- each module should have a simple and clean interface

Module independence measured using two criteria:
1. __Cohesion:__ degree to which a module focuses on a group of related functions
2. __Coupling:__ degree to which a module is connected to / depends on other modules

Good design = high cohesion and low coupling.

__Product family:__ set of software intensive systems that share a common set of features.
- Design and implement core features just once
- Differences or variations are pushed down the stack (think of abstraction of functionality, parent child relationships, inheritance, and polymorphism)

## OO Design

__How to find / determine what should be a class?__

Heuristic: classes correspond to _nouns_ in the natural language decomposition of the problem.

Some nouns _do not_ correspond to classes:
- items outside the problem boundary
- some nouns are just attributes (e.g., student id, birthday, student email)
- synonyms or words used to refer to a single concept

__Tangible:__ physical objects or object groups that are tangible (e.g., Medication, Receipt, Prescription, Medical Record)

__Roles:__ people who perform certain actions or have responsabilities or duties (e.g., Doctor, Nurse, Administrative assistant)

__Events:__ things that can happen

__Interactions between roles:__ e.g., exams, immunizations, diagnosis

__Other systems:__ external events or systems with which the system interacts (e.g., credit card system, insurance system..)

__Comparison between interface and the "tip of the iceberg"__
- possible for a ship to avoid an iceberg simply by viewing the top
- possible for a client to use a module by knowing its interface

__Symbol Table__

`get`: returns value

`put`: store / update value

`get` method should only return the value of the variable. It should not return the variable location (i.e., memory address). If memory address is returned, then user can access location directly and modify the value of the variable rather than doing it through the `put` method.

Documentation should be structured top down:
- level of detail increases as one proceeds down
- big picture first, provide additional details as you drill down into specifics

Interface hides implementation details like:
- algorithm
- data structure
- external services integration
- policy

__How does inheritance promote re-use?__
- promotes re-use because child class inherits data & behaviour from the parent class
- code does not need to be re-written for the child
- child can refer to and use data + methods from parent

__Conflict in inheritance (Extension or Restriction)__ ???
__Extension:__
- behaviour / data in a child class are an extension an extension of parent class
- child class has all properties of parent class and adds some more

__Restriction View:__
- child class is a more specialized (restricted) case of a parent
- contraction

__Functional or procedural programming__
- program divided into smaller parts functions
- start with a problem and break it down into smaller problems
- break down sub-problems continually in a process called functional decomposition
- continue until each sub-procedure is simple enough to be implemented in code

__OOP__
- program divided into small parts called objects (bottom up design approach)
- start with basic level of classes and build upon those classes

__Composition__

Describes "has a" relationship

__Inheritance__

Describes "is a" relationship

| has-a| is-a |
|------|------|
|car has-a engine| dog is-a animal|
|game has-a player| car is-a vehicle|
|db has-a entry| employee is-a person|
|university has-a student| orange is-a fruit|
|playlist has-a song||

__Advatages of composition over inheritance__

1. Java does not support multiple inheritance. For reading and writing you can compose your class with `Reader` and `Writer`. You cannot implement more than one interface.

2. Easier testing. You can easily create a mock object and inject that as a dependency to test vs. having to implement and inherit super class.

3. Inheritance provides "tight coupling." If parent changes, child may break (e.g., removal of class in parent that is used in child).

4. Flexibility. For example, `Comparator` can be passed to `Collections.sort()` for custom sorting behaviour. This is convenient if you want to provide sorting behaviour other than default ([see](https://www.youtube.com/watch?v=oAp4GYprVHM)).

__UML__

"+" indicates field or method is `public`

"-" indivate field or method is `private`

__Understanding the Utility of Classes__
- Inheritance and delegation facilitate re-use

We can breakdown the classes in a software application into these groups:

1. Domain-independent (20%):
- provide functionality regardless of domain
- e.g., data structures, math functions, file IO, UI components

2. Domain-specific (65%):
- functions that function specific to a domain
- e.g., inventory control (inventory of video tape rentals, auto parts)
- likely to be used in current and future projects

3. Application-specific (15%):
- special purpose, classes that implement custom logic specific to application

__"85% of code is reusable":__ organizations should strive for domain-independent and domain-specific use

__Composition (i.e., Containment)__
- class spawns and contains instances of other classes within it
- "part-of" relationship
- if containing class is freed by garbage collector, then so are all of its composing actors / entities

__Inheritance__
- re-use of code from another class
- child inherits data + methods from parent (if accessibility is `public` or `protected`)
- "is-a" relationship

__Inheritance vs Composition__
- with inheritance we focus on defining / implementing things based on what they __are__
  - is "B" a kind of "A"? if yes -> use inheritance
- with composition we focus on defining / implementing things based on what they __do__
  - does B have an A? if yes -> use composition
  
With inheritance we often face the gorilla banana problem.. which is when we only ask for a banana but we get a gorilla holding a banana with the entire jungle in the background. In other words, we get more than we ask for and make the code more bulky / convoluted. See this: [watch](https://www.youtube.com/watch?v=wfMtDGfHWpA)

__Class Relationships__
1. Association
2. Aggregation
3. Composition

__Association__
- objects of one class are associated with objects from another class
- a relationship where all objects have their own lifecycle and there is no owner

__Aggregation__
- more specific variant of aggregation
- "has-a" relationship
- superset class made up of components from subset classes
- no existence dependency between superset and subset classes (i.e., superset can be removed w/o needing to remove subset class)

__Composition__
- more specific variant of aggregation
- "part of" relationship
- object of a subset class cannot exist w/o being linked to an object of the superset class
- if we destroy a superset object, then we must delete the subset object as well

![Image of UML Notations](https://s3.amazonaws.com/gutucristian.github.io/Association%2C+Composition+UML.JPG)

__When to use inheritance__
- "is-a" test
- code reuse

__Polymorphism / Dispatching__
- Runtime or dynamic choice of the method to be invoked depending on the class of the invoking object
- polymorphism is based on inheritance.. parent child relationship is required

__Polymorphism benefits__
- offer versatility in hierarchy and code development
- makes code more generic and increases reuse

__Principles of Substitutability__
- If A is a subclass of B, instances of A can be substituted for instances of B in any situation without any observable effect

__Subtype vs Subclass__
- A is a __subclass__ of B merely asserts that A is formed using inheritance
  - refers to a general inheritance relationship that may or may not satisfy the substitutability principle
- A is a __subtype__ of B means A preserves the meaning of all operations in B
  - refers to an inheritance relationship that satisfies the substitutability principle
- good reads [here](https://courses.cs.washington.edu/courses/cse331/16wi/L12/L12-Subtyping.pdf) and the course directory [here](https://courses.cs.washington.edu/courses/cse331/16wi/)

__Overiding__
- child class overides a method in the parent class (i.e., child class provides new implementation for method inherited from parent)
- overridden method has same name and type signature as the parent class, but changed implementation

__Specialization Inheritance__
- each child class preserves the behaviour of the parent
- may add more functions / data
- preserves substitutability

__Specification Inheritance__
- all child classes implement the methods defined in the parent
- more specific version of specialization inheritance
- preserves substitutability

__Construction Inheritance__
- parent class is used as a source of behaviour 
- child class has no "is-a" relationship to the parent
- child class may modify arguments
- may not preserve the behaviour of the parent
- violates substitutability

__Generalization__
- adds new features reutnrs existing ones
- preserves

__Limitation__
- child class overrides a method inherited from a parent in a way that makes it unusable or limits certain functions
- e.g., list data type that allows items to be inserted at either end
- e.g., limit by allowing insertion only at one end to create a stack
- violates

__Variance__
- Two or more classes that seem to be related but not clear which is child and which is parent
- May or may not preserve substitutability principle

__Correctness vs Reliability__
- Reliability encompasses correctness

__When is a software system: correct yet unreliable or reliable yet incorrect__
- requirements may not be well understood or an accurate representation of what the user wants
- requirments may not be known to user.. if this is the case, then software builds for these incorrect reqs will never behave as expected to the user -> not reliable from the user's perspective
- software system may perform critical functions w/o failure but may be able to tolerate some flaws in non-critical functions
- system is incorrect yet reliable

__Robustness vs. Application Domain__
- How a particular unforeseen circumstance can occur will depend on the application domain
- if software is developed for users who are not conversant with tech, application must be prepared to accept ill-formatted or incorrect inputs
- embedded systems never use input from users, but interface with sensors and may need to handle sensor and hardware failure
- amt. of code dedicated to handling errors depends on domain and consequences of failures

__Relationship between requirements, correctness, reliability, and robustness__
- if requirements are specified then ensuring is a matter of correctness / reliability
- if requirements are not specified then it is a matter of robustness

__Three levels of interoperability__
1. __Minimum:__ multiple applications must coexist on the same machine
2. __Medium:__ one application must be able to embed or import data from another application (e.g., import powerpoint into google slides)
3. __Maximum:__ software sytem must interface and exchange data with other systems

__How reusability affects reliability__
- as more components are reused they are more likely to become reliabled since residual errors are progressively eliminated
- reliability of components improves leading to an improvement in sys. reliability
- components may also behave in unexpected ways which would lead to lower component and system reliability

__Real-time system__
- correct answer generated within a specified time delta
- tradeoff precision for timeliness
- performance is most important

__Information system__
- e.g., payroll system
- live much longer than originally planned
- adapted to new environments, enhanced with new features
- maintainability

__UI and reliability__
- well designed UI can direct a user through the sequence of necesarry steps to complete a task
- bad UI may cause a user to try alternate things and crash the app

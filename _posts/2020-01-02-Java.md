An issue I ran into when using IntelliJ IDEA is not being able to view Java source code, declarations, and Javadocs. This can be resolved by going to your `src` folder (i.e., where your source code is located). Right click, navigate and toggle: __Mark Directory As > Sources Root__ ([link](https://stackoverflow.com/questions/37282285/intellij-cannot-find-any-declarations])).

__What is `transient` keyword?__

The `transient` keyword in Java is used to indicate that a field should not be part of the serialization. A `transient` variable is not part of the persistent state of an object. For example, if you have fields that are derived from other fields (programatically) then we can mark them as `transient` to prevent their state from being persisted during serialization. This helps save memory and increases speed of serialization / deserialization process. Say we have a `GalleryImage` class that `implements Serializable`. Among other instance variables / methods, assume this class contains two instance variables: `image` and `thumbnailImage`. The `thumbnailImage` is derived from the gallery `image`. Upon deserialization, the `readObject` method is called to perform any operations necessary to restore the state of the object. In this example, the `thumbnailImage` needs to be regenerated. Thus, we override the `readObject` method do that the thumbnail will be generated by calling a `generateThumbnail` method ([link](https://stackoverflow.com/questions/910374/why-does-java-have-transient-fields)).

#### Composition 
Describes "has a" relationship

#### Inheritance 
Describes "is a" relationship

#### Advatages of composition over inheritance

1. Java does not support multiple inheritance. For reading and writing you can compose your class with `Reader` and `Writer`. You cannot implement more than one interface.

2. Easier testing. You can easily create a mock object and inject that as a dependency to test vs. having to implement and inherit super class.

3. Inheritance provides "tight coupling." If parent changes, child may break (e.g., removal of class in parent that is used in child).

4. Flexibility. For example, `Comparator` can be passed to `Collections.sort()` for custom sorting behaviour. This is convenient if you want to provide sorting behaviour other than default ([see](https://www.youtube.com/watch?v=oAp4GYprVHM)).

#### UML

"+" indicates field or method is `public`

"-" indivate field or method is `private`

# Software Design

## Change 

Change is distinguishing feature that makes software different from any other human produced artifact:
- Since the 1970's, change in software is constant, urgent, and unavoidable. Mastering change is inevitable.
- Software technology has made progress but change is treated as an afterthought.
- Change has to become a first class concept
  - development tools, runtime environment, and design process should naturally accomodate change

Two types of change:
1. Evolution, and
2. Adaptation

__Evolution:__ enhancing the software with new functions and features

__Adaptation:__ retrofitting or improving the relevance of a software system in a new environment (e.g., building mobile versions of desktop apps, porting Windows based app to MacOS).

__Change of Social Environment__
- change is necessary due to external influence
- factors beyond the control of software organizations, clients, and users
- changes are often hard to anticipate and difficult to implement
- often, programmers have to respond to these changes under severe time pressure

Examples of changes that require software change:
- new tax laws (for a tax software.. e.g., TurboTax)
- move of EU to common currency
- change in safety requirements (e.g., Boeing)

## Modules

__Properties of USES relationship__

__fan-in__: number of incoming edges indicates the number of modules that use (or "depend") on this module.

__fan-out__: number of outgoing edges indicates the number of modules this module depend on

Low fan-out / high fan-in is desirable because:
- this implies loose coupling (modules are not highly dependent on each other). Loose coupling increases maintainability, scalability, and reduces bugs
- implies that modules are a good abstraction

__Properties of modular design__

Principles:
- each module should address a specific subfunction of the requirements
- each module should have a simple and clean interface

Module independence measured using two criteria:
1. __Cohesion:__ degree to which a module focuses on a group of related functions
2. __Coupling:__ degree to which a module is connected to / depends on other modules

Good design = high cohesion and low coupling.

__Product family:__ set of software intensive systems that share a common set of features.
- Design and implement core features just once
- Differences or variations are pushed down the stack (think of abstraction of functionality, parent child relationships, inheritance, and polymorphism)

## OO Design

__How to find / determine what should be a class?__

Heuristic: classes correspond to _nouns_ in the natural language decomposition of the problem.

Some nouns _do not_ correspond to classes:
- items outside the problem boundary
- some nouns are just attributes (e.g., student id, birthday, student email)
- synonyms or words used to refer to a single concept

__Tangible:__ physical objects or object groups that are tangible (e.g., Medication, Receipt, Prescription, Medical Record)

__Roles:__ people who perform certain actions or have responsabilities or duties (e.g., Doctor, Nurse, Administrative assistant)

__Events:__ things that can happen

__Interactions between roles:__ e.g., exams, immunizations, diagnosis

__Other systems:__ external events or systems with which the system interacts (e.g., credit card system, insurance system..)

__Comparison between interface and the "tip of the iceberg"__
- possible for a ship to avoid an iceberg simply by viewing the top
- possible for a client to use a module by knowing its interface

__Symbol Table__

`get`: returns value

`put`: store / update value

`get` method should only return the value of the variable. It should not return the variable location (i.e., memory address). If memory address is returned, then user can access location directly and modify the value of the variable rather than doing it through the `put` method.

Documentation should be structured top down:
- level of detail increases as one proceeds down
- big picture first, provide additional details as you drill down into specifics

Interface hides implementation details like:
- algorithm
- data structure
- external services integration
- policy
